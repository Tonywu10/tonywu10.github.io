<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Problem 105 Construct Binary Tree from Preorder and Inorder Traversal/Problem 106 Construct Binary Tree from Inorder and Postorder Traversal/Problem 114 Flatten Binary Tree to Linked List/Problem 134">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode刷题记录(Java)">
<meta property="og:url" content="http://yoursite.com/2019/12/22/Leetcode刷题记录(Java) _12_22/index.html">
<meta property="og:site_name" content="小吴的程序屋">
<meta property="og:description" content="Problem 105 Construct Binary Tree from Preorder and Inorder Traversal/Problem 106 Construct Binary Tree from Inorder and Postorder Traversal/Problem 114 Flatten Binary Tree to Linked List/Problem 134">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/QxrP0J.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/QxcDqU.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/QxfdDP.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/Qxo3pF.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/Qxbfbj.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/Qziyv9.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/QzFIoV.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/QzkB6J.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/QzVonJ.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/QzcxBT.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/Qzflo8.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/22/Qz4wPU.png">
<meta property="og:updated_time" content="2019-12-22T14:03:40.228Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode刷题记录(Java)">
<meta name="twitter:description" content="Problem 105 Construct Binary Tree from Preorder and Inorder Traversal/Problem 106 Construct Binary Tree from Inorder and Postorder Traversal/Problem 114 Flatten Binary Tree to Linked List/Problem 134">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/12/22/QxrP0J.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/22/Leetcode刷题记录(Java) _12_22/"/>





  <title>Leetcode刷题记录(Java) | 小吴的程序屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小吴的程序屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">图像、算法、杂谈以及更多</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/22/Leetcode刷题记录(Java) _12_22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/batman.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小吴的程序屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode刷题记录(Java)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-22T00:00:00+08:00">
                2019-12-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-12-22T22:03:40+08:00">
                2019-12-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  Problem 105 Construct Binary Tree from Preorder and Inorder Traversal/Problem 106 Construct Binary Tree from Inorder and Postorder Traversal/Problem 114 Flatten Binary Tree to Linked List/Problem 134 Gas Station/Problem 139 Word Break/Problem 142 Linked List Cycle II/Problem 143 Reorder List/Problem 148 Sort List/Problem 152 Maximum Product Subarray/Problem 179 Largest Number/Problem 207 Course Schedule
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Problem 105 Construct Binary Tree from Preorder and Inorder Traversal<br><img src="https://s2.ax1x.com/2019/12/22/QxrP0J.png" alt="QxrP0J.png"><br>根据先序遍历和中序遍历的结果构建二叉树</p>
<hr>
<p>主要思路:<br>根据先序遍历和中序遍历的性质对元素进行定位</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        return helper(0,0,inorder.length-1,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(int preStart,int inStart,int inEnd,int[] preorder,int[] inorder)&#123;</span><br><span class="line">        if (preStart&gt;preorder.length-1||inStart&gt;inEnd)</span><br><span class="line">            return null;</span><br><span class="line">        TreeNode root = new TreeNode(preorder[preStart]);</span><br><span class="line">        int inIndex = 0;</span><br><span class="line">        for (int i=inStart;i&lt;=inEnd;i++)&#123;</span><br><span class="line">            if (inorder[i]==root.val)&#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = helper(preStart+1,inStart,inIndex-1,preorder,inorder);</span><br><span class="line">        root.right = helper(preStart+inIndex-inStart+1,inIndex+1,inEnd,preorder,inorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>代码说明:<br>以题目给出的先序遍历[3,9,20,15,7]和中序遍历[9,3,15,20,7]为例,在 helper 中先确定 root 的值,第一次进去就是先序的第一个值,也就是 3.然后的循环是为了找出当前这个 root 在中序遍历中的下标,比如本例中,inIndex=1,然后为 root 加上 left 和 right,left 就是先序遍历中 root 的右边结点,也就是 preStart+1,而右子树是右边 preStart+1+inIndex-inStart<br>左子树:root.left = helper(前序左子树范围,中序左子树范围,前序序列,中序序列)<br>右子树:root.right = helper(前序右子树范围,中序右子树范围,前序序列,中序序列)</p>
<hr>
<p>Problem 106 Construct Binary Tree from Inorder and Postorder Traversal<br><img src="https://s2.ax1x.com/2019/12/22/QxcDqU.png" alt="QxcDqU.png"><br>根据先序遍历和后序遍历的结果构建二叉树</p>
<hr>
<p>主要思路:<br>根据中序遍历和后序遍历的性质对元素进行定位</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        if (null == postorder || postorder.length &lt; 1) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return buildTree(inorder, 0, inorder.length - 1, postorder, postorder.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode buildTree(int[] inorder, int start, int end, int[] postorder, int idx) &#123;</span><br><span class="line">        if (start &gt; end || idx &lt; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = new TreeNode(postorder[idx]);</span><br><span class="line">        int rIdx = start;</span><br><span class="line">        for (; rIdx &lt;= end; rIdx++) &#123;</span><br><span class="line">            if (inorder[rIdx] == postorder[idx]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = buildTree(inorder, start, rIdx - 1, postorder, idx - (end - rIdx) - 1);</span><br><span class="line">        root.right = buildTree(inorder, rIdx + 1, end, postorder, idx - 1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>代码说明:<br>以中序[9,3,15,20,7]和后序[9,15,7,20,3]为例,根据性质,后序数组的最后一个元素自然是根节点,它左边那个元素自然是它的右子树,剩下的问题是确定左子树,左子树需要找到先序遍历中根节点的位置,然后取其左边元素</p>
<hr>
<p>Problem 114 Flatten Binary Tree to Linked List<br><img src="https://s2.ax1x.com/2019/12/22/QxfdDP.png" alt="QxfdDP.png"><br>将二叉树转换成链表</p>
<hr>
<p>主要思路:<br>可以考虑先将根节点的左子树全部压平再将右子树全部压平,最后将压平的左子树插入到右子树中</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        if (root==null)</span><br><span class="line">            return;</span><br><span class="line">        if (root.left!=null)</span><br><span class="line">            flatten(root.left);</span><br><span class="line">        if (root.right!=null)</span><br><span class="line">            flatten(root.right);</span><br><span class="line">        TreeNode temp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = null;</span><br><span class="line">        while (root.right!=null)</span><br><span class="line">            root = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>代码说明:<br>以题目中给定的树为例,最先运行到最左非叶子结点,在本例中为 2,保存 temp=4.然后将 root.left(3)当作 root.right,完成 2-&gt;3,并将 left 置为 null,随后就是 root 一直朝着右边移动,最后将最初存储的 temp 接在最后,完成左边 2-&gt;3-&gt;4,随后完成右边 1-&gt;5-&gt;6.最后一步就是合并,1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</p>
<hr>
<p>Problem 134 Gas Station<br><img src="https://s2.ax1x.com/2019/12/22/Qxo3pF.png" alt="Qxo3pF.png"><br>给定一个 gas 数组,一个 cost 数组,gas 数组是车在当前加油站能够补充的油,cost 数组是要从当前加油站移动到相邻加油站所需要消耗的油.如果能够从起点绕一圈回到起点,则返回起点下标.否则返回-1</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        int total = 0, sum = 0, start = 0;</span><br><span class="line">        for (int i = 0; i &lt; gas.length; ++i) &#123;</span><br><span class="line">            total += gas[i] - cost[i];</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">            if (sum &lt; 0) &#123;</span><br><span class="line">                start = i + 1;</span><br><span class="line">                sum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (total &lt; 0) ? -1 : start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>代码说明:<br>这段代码主要要注意两个变量:一个是<strong>total</strong>,它用来记录总共能加的油是否比总共消耗的多,如果加的总数没有消耗的多,那么无论怎么走都无法绕一圈.另一个是<strong>sum</strong>,它用来记录从起点到当前结点的累计量.如果 sum 小于 0,代表着从起点到当前结点的累计加上当前结点的净消耗不足以让它离开,这说明这段内的所有结点都不适合当起点.那么将起点设为当前结点的下一个,而不需要从原先结点的下一个遍历.</p>
<hr>
<p>Problem 139 Word Break<br><img src="https://s2.ax1x.com/2019/12/22/Qxbfbj.png" alt="Qxbfbj.png"><br>判断给出的字符串能否由数组中的字符串数组组成</p>
<hr>
<p>主要思路:<br>本题利用动态规划的思想来解,每次取一个 s 的子序列,判断它是否在数组中,不断填充 dp 数组</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        if (s==null||s.length()==0)</span><br><span class="line">            return false;</span><br><span class="line">        boolean[] dp = new boolean[s.length()+1];</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        for (int i=1;i&lt;=s.length();i++)&#123;</span><br><span class="line">            for (int j=0;j&lt;=i;j++)&#123;</span><br><span class="line">                if (dp[j]&amp;&amp;wordDict.contains(s.substring(j,i)))&#123;</span><br><span class="line">                    dp[i] = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>代码说明:<br>以题中给出的例子 3 为例,dp[0]=1,然后开始取子序列,<br>i=1<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(c)=false,不更新<br>j=1 dp[1]=false,不更新</p>
<p>i=2<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(ca)=false,不更新<br>j=1 dp[1]=false,不更新<br>j=2 dp[2]=false,不更新</p>
<p>i=3<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(cat)=true,dp[3]=true,break</p>
<p>i=4<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(cats)=true,dp[4]=true,break</p>
<p>i=5<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(catsa)=false,不更新<br>j=1 dp[1]=true&amp;&amp;wordDict.contains(atsa)=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=true&amp;&amp;wordDict.contains(sa)=false,不更新<br>j=4 dp[4]=true&amp;&amp;wordDict.contains(a)=false,不更新<br>j=5 dp[5]=false,不更新</p>
<p>i=6<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(catsan)=false,不更新<br>j=1 dp[1]=true&amp;&amp;wordDict.contains(atsan)=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=true&amp;&amp;wordDict.contains(san)=false,不更新<br>j=4 dp[4]=true&amp;&amp;wordDict.contains(an)=false,不更新<br>j=5 dp[5]=false,不更新<br>j=6 dp[6]=false,不更新</p>
<p>i=7<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(catsand)=false,不更新<br>j=1 dp[1]=true&amp;&amp;wordDict.contains(atsand)=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=true&amp;&amp;wordDict.contains(sand)=true,dp[7]=true,break</p>
<p>i=8<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(catsando)=false,不更新<br>j=1 dp[1]=true&amp;&amp;wordDict.contains(atsando)=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=true&amp;&amp;wordDict.contains(sando)=false,不更新<br>j=4 dp[4]=true&amp;&amp;wordDict.contains(ando)=false,不更新<br>j=5 dp[5]=false,不更新<br>j=6 dp[6]=false,不更新<br>j=7 dp[7]=true&amp;&amp;wordDict.contains(o)=false,不更新<br>j=8 dp[8]=false,不更新</p>
<p>i=9<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(catsandog)=false,不更新<br>j=1 dp[1]=true&amp;&amp;wordDict.contains(atsandog)=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=true&amp;&amp;wordDict.contains(sandog)=false,不更新<br>j=4 dp[4]=true&amp;&amp;wordDict.contains(andog)=false,不更新<br>j=5 dp[5]=false,不更新<br>j=6 dp[6]=false,不更新<br>j=7 dp[7]=true&amp;&amp;wordDict.contains(og)=false,不更新<br>j=8 dp[8]=false,不更新<br>j=9 dp[9]=false,不更新<br>结束,最后判断 dp[9]为 false,故无法组成</p>
<hr>
<p>再以例子 1 为例<br>i=1<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(l)=false,不更新<br>j=1 dp[1]=false,不更新</p>
<p>i=2<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(le)=false,不更新<br>j=1 dp[1]=false,不更新<br>j=2 dp[2]=false,不更新</p>
<p>i=3<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(lee)=false,不更新<br>j=1 dp[1]=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=false,不更新</p>
<p>i=4<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(leet)=true,dp[4]=true,break</p>
<p>i=5<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(leetc)=false,不更新<br>j=1 dp[1]=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=false,不更新<br>j=4 dp[4]=true&amp;&amp;wordDict.contains(c)=false,不更新<br>j=5 dp[5]=false,不更新</p>
<p>i=6<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(leetco)=false,不更新<br>j=1 dp[1]=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=false,不更新<br>j=4 dp[4]=true&amp;&amp;wordDict.contains(co)=false,不更新<br>j=5 dp[5]=false,不更新<br>j=6 dp[6]=false,不更新</p>
<p>i=7<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(leetcod)=false,不更新<br>j=1 dp[1]=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=false,不更新<br>j=4 dp[4]=true&amp;&amp;wordDict.contains(cod)=false,不更新<br>j=5 dp[5]=false,不更新<br>j=6 dp[6]=false,不更新<br>j=7 dp[7]=false,不更新</p>
<p>i=8<br>j=0 dp[0]=true&amp;&amp;wordDict.contains(leetcode)=false,不更新<br>j=1 dp[1]=false,不更新<br>j=2 dp[2]=false,不更新<br>j=3 dp[3]=false,不更新<br>j=4 dp[4]=true&amp;&amp;wordDict.contains(code)=true,dp[8]=true,break</p>
<p>结束,最后判断 dp[8]为 true,故可以组成</p>
<hr>
<p>Problem 142 Linked List Cycle II<br><img src="https://s2.ax1x.com/2019/12/22/Qziyv9.png" alt="Qziyv9.png"><br>先判断链表有没有环,再判断环的入口在哪个结点</p>
<hr>
<p>主要思路:<br>首先判断链表有没有环,可以使用快慢指针进行判断.因为如果有环,那么首先快指针不会指向 null,然后快指针每次都逼近慢指针 1 个单位.这样它们肯定会相遇.<br><img src="https://s2.ax1x.com/2019/12/22/QzFIoV.jpg" alt="QzFIoV.jpg"><br>然后根据上图判断环的入口,假设相遇点是 z,那么快指针走了 a+b+c+b 的距离,慢指针走了 a+b,由于快指针=2*慢指针,所以 a+b+c+b=2*(a+b)=&gt;a=c,也就是说慢指针从头部重新走和快指针从相遇点继续走相遇的结点就是环的入口</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = head;</span><br><span class="line">        while(q.next != null &amp;&amp; q.next.next != null)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">            if(q == p)&#123;</span><br><span class="line">                p = head;</span><br><span class="line">                while(p != q)&#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    q = q.next;</span><br><span class="line">                &#125;</span><br><span class="line">                return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Problem 143 Reorder List<br><img src="https://s2.ax1x.com/2019/12/22/QzkB6J.png" alt="QzkB6J.png"><br>对链表进行重排列</p>
<hr>
<p>主要思路:</p>
<ul>
<li>通过快慢指针定位链表中点</li>
<li>反转后半链表</li>
<li>将后半链表的元素按顺序插入到前半链表中</li>
</ul>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void reorderList(ListNode head) &#123;</span><br><span class="line">        if(head == null) return;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        while(fast!= null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode reverseHead = reverse(slow.next);</span><br><span class="line">        slow.next = null;</span><br><span class="line">        ListNode currHead = head;</span><br><span class="line">        while(reverseHead != null)&#123;</span><br><span class="line">            ListNode firstNext = currHead.next;</span><br><span class="line">            ListNode secondNext = reverseHead.next;</span><br><span class="line">            currHead.next = reverseHead;</span><br><span class="line">            reverseHead.next = firstNext;</span><br><span class="line">            currHead = firstNext;</span><br><span class="line">            reverseHead = secondNext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ListNode reverse(ListNode head) &#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        ListNode prev = null;</span><br><span class="line">        while(curr != null)&#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Problem 148 Sort List<br><img src="https://s2.ax1x.com/2019/12/22/QzVonJ.png" alt="QzVonJ.png"><br>链表排序</p>
<hr>
<p>主要思路:<br>题目要求时间复杂度 O(nlogn),那么可以考虑归并排序</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode sortList(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) return head;</span><br><span class="line">        return sort(head);</span><br><span class="line">    &#125;</span><br><span class="line">    private ListNode merge(ListNode left, ListNode right) &#123;</span><br><span class="line">        ListNode dummy = new ListNode(-1);</span><br><span class="line">        ListNode node = dummy;</span><br><span class="line">        while (left != null &amp;&amp; right != null) &#123;</span><br><span class="line">            if (left.val &lt; right.val) &#123;</span><br><span class="line">                node.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (left != null) &#123;</span><br><span class="line">            node.next = left;</span><br><span class="line">            node = node.next;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (right != null) &#123;</span><br><span class="line">            node.next = right;</span><br><span class="line">            node = node.next;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ListNode sort(ListNode head) &#123;</span><br><span class="line">        // 1 element</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2 elements</span><br><span class="line">        if (head.next.next == null) &#123;</span><br><span class="line">            if (head.val &gt; head.next.val) &#123;</span><br><span class="line">                ListNode t = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                head.next = t;</span><br><span class="line">                t.next = null;</span><br><span class="line">            &#125;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        // more elements</span><br><span class="line">        ListNode slower = head, faster = head;</span><br><span class="line">        while (faster != null &amp;&amp; faster.next != null) &#123;</span><br><span class="line">            slower = slower.next;</span><br><span class="line">            faster = faster.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slowerNext = slower.next;</span><br><span class="line">        slower.next = null;</span><br><span class="line">        return merge(sort(head), sort(slowerNext));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明:<br>代码看起来比较复杂,但是逻辑比较清晰.首先考虑 1 个元素和 2 个元素的情况.之后就是多个元素,归并排序是将链表分为左右两边.此时必然用到快慢指针.分好之后进行归并,归并时分别比较前半部分和后半部分第一个元素的大小,较小的插入到 dummy.next 中.然后移动较小那部分的指针以及 dummy 指针.依次比较,直到有一方排序结束</p>
<hr>
<p>Problem 152 Maximum Product Subarray<br><img src="https://s2.ax1x.com/2019/12/22/QzcxBT.png" alt="QzcxBT.png"><br>求数组的最大子序列之积</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 当遍历到一个正数时，此时的最大值等于之前的最大值乘以这个正数和当前正数中的较大值，此时的最小值等于之前的最小值乘以这个正数和当前正数中的较小值。</span><br><span class="line">     * 当遍历到一个负数时，先用一个变量t保存之前的最大值 mx，然后此时的最大值等于之前最小值乘以这个负数和当前负数中的较大值，此时的最小值等于之前保存的最大值t乘以这个负数和当前负数中的较小值。</span><br><span class="line">     * 在每遍历完一个数时，都要更新最终的最大值。</span><br><span class="line">     * @param nums</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        if (nums.length==1)</span><br><span class="line">            return nums[0];</span><br><span class="line">        int max = nums[0],min = nums[0],maxAns = nums[0];</span><br><span class="line">        for (int i=1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            int mx = max,mn = min;</span><br><span class="line">            max = Math.max(Math.max(nums[i],mx*nums[i]),mn*nums[i]);</span><br><span class="line">            min = Math.min(Math.min(nums[i],mx*nums[i]),mn*nums[i]);</span><br><span class="line">            maxAns = Math.max(max,maxAns);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Problem 179 Largest Number<br><img src="https://s2.ax1x.com/2019/12/22/Qzflo8.png" alt="Qzflo8.png"><br>给定一个 int 数组,要求返回这些 int 能够组成的最大数字(由于数字可能会大到溢出,所以以字符串形式返回)</p>
<hr>
<p>主要思路:<br>直接对数组排序,不过排序的规则是比较 a+b 和 b+a 的值谁比较大,比如 3 和 34,是组成 334 还是 343,自然是 343 比较大,所以 34 排在 3 前面</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static String largestNumber(int[] nums) &#123;</span><br><span class="line">        if (nums == null || nums.length == 0) return &quot;&quot;;</span><br><span class="line">        String[] strs = new String[nums.length];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(strs, (i, j) -&gt; &#123;</span><br><span class="line">            String s1 = i+j;</span><br><span class="line">            String s2 = j+i;</span><br><span class="line">            return s2.compareTo(s1);</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        for (String str : strs) &#123;</span><br><span class="line">            res.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        return res.charAt(0) ==&apos;0&apos; ? &quot;0&quot;: res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Problem 207 Course Schedule<br><img src="https://s2.ax1x.com/2019/12/22/Qz4wPU.png" alt="Qz4wPU.png"><br>给定课程数目,以及一个二维数组,数组中的每个元素的第一个元素代表要上的课,第二个元素代表要上课之前需要上的前序课程,需要判断能否达到无环状态</p>
<hr>
<p>主要思路:<br>实际上是个拓扑排序的题目,对每个结点初始化入度.当所有入度消失之后取出当前元素.</p>
<hr>
<p>代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        int[] indegree = new int[numCourses];</span><br><span class="line">        for (int[] pair:prerequisites)</span><br><span class="line">            indegree[pair[0]]++;</span><br><span class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int i=0;i&lt;indegree.length;i++)&#123;</span><br><span class="line">            if (indegree[i]==0)</span><br><span class="line">                queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int size = queue.size();</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            int top = queue.remove();</span><br><span class="line">            for (int[] prerequisite : prerequisites) &#123;</span><br><span class="line">                if (prerequisite[1] == top) &#123;</span><br><span class="line">                    indegree[prerequisite[0]]--;</span><br><span class="line">                    if (indegree[prerequisite[0]] == 0) &#123;</span><br><span class="line">                        size++;</span><br><span class="line">                        queue.add(prerequisite[0]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size==numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/21/Leetcode刷题记录(Java) _12_21/" rel="next" title="Leetcode刷题记录(Java)">
                <i class="fa fa-chevron-left"></i> Leetcode刷题记录(Java)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/06/Dynamic Key-Value Memory Networks for Knowledge Tracing/" rel="prev" title="Dynamic Key-Value Memory Networks for Knowledge Tracing">
                Dynamic Key-Value Memory Networks for Knowledge Tracing <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/batman.png"
                alt="Tony Wu" />
            
              <p class="site-author-name" itemprop="name">Tony Wu</p>
              <p class="site-description motion-element" itemprop="description">一些算法、一些划水</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-google"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tony Wu</span>

  
</div>










        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
