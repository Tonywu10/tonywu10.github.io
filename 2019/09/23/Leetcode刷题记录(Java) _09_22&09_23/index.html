<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Problem 594 Longest Harmonious Subsequence/Problem 606 Construct String from Binary Tree/Problem 617 Merge Two Binary Trees/Problem 643 Maximum Average Subarray I/Problem 653 Two Sum IV - Input is a B">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode刷题记录(Java)">
<meta property="og:url" content="http://yoursite.com/2019/09/23/Leetcode刷题记录(Java) _09_22&09_23/index.html">
<meta property="og:site_name" content="小吴的程序屋">
<meta property="og:description" content="Problem 594 Longest Harmonious Subsequence/Problem 606 Construct String from Binary Tree/Problem 617 Merge Two Binary Trees/Problem 643 Maximum Average Subarray I/Problem 653 Two Sum IV - Input is a B">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/uFogWF.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/uFb8XQ.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/uFbTnH.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/uFLWQO.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/uFjWlV.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/uFxYxP.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/uk9WlR.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/ukkyRg.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/ukZfcF.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/24/ukns7d.png">
<meta property="og:updated_time" content="2019-09-24T03:51:39.958Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode刷题记录(Java)">
<meta name="twitter:description" content="Problem 594 Longest Harmonious Subsequence/Problem 606 Construct String from Binary Tree/Problem 617 Merge Two Binary Trees/Problem 643 Maximum Average Subarray I/Problem 653 Two Sum IV - Input is a B">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/09/24/uFogWF.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/23/Leetcode刷题记录(Java) _09_22&09_23/"/>





  <title>Leetcode刷题记录(Java) | 小吴的程序屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小吴的程序屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">图像、算法、杂谈以及更多</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/23/Leetcode刷题记录(Java) _09_22&09_23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/batman.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小吴的程序屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode刷题记录(Java)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-23T00:00:00+08:00">
                2019-09-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-24T11:51:39+08:00">
                2019-09-24
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  Problem 594 Longest Harmonious Subsequence/Problem 606 Construct String from Binary Tree/Problem 617 Merge Two Binary Trees/Problem 643 Maximum Average Subarray I/Problem 653 Two Sum IV - Input is a BST/Problem 665 Non-decreasing Array/Problem 669 Trim a Binary Search Tree/Problem 680 Valid Palindrome II/Problem 696 Count Binary Substrings/Problem 687 Longest Univalue Path
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Problem 594 Longest Harmonious Subsequence<br><img src="https://s2.ax1x.com/2019/09/24/uFogWF.png" alt="uFogWF.png"><br>找出最大值和最小值相差不大于1的最长子序列,子序列不要求数组连续.</p>
<hr>
<p>主要思路:<br>这个题目一个很直观的思路就是排序之后找出两个相邻不等的值的最长长度,先排序,再使用map存储数据,再循环如果两个数之差不大于1就计数.后来看别人的思路,有人采用map加上单次循环的策略,省略了排序这个步骤.</p>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findLHS(int[] nums) &#123;</span><br><span class="line">        int max = 0;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, 0) + 1);</span><br><span class="line">            int lower = map.getOrDefault(num - 1, 0);</span><br><span class="line">            int upper = map.getOrDefault(num + 1, 0);</span><br><span class="line">            if (lower != 0) max = Math.max(max, lower + map.get(num));</span><br><span class="line">            if (upper != 0) max = Math.max(max, upper + map.get(num));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>代码说明:<br>以题目给出的1,3,2,2,5,2,3,7为例,循环开始之后map的情况为{1=1},由于max和min的差距不大于1,也就是说取比当前值大1或者小1或当前值均可,lower=0,upper=0;开始第二轮循环,map的情况为{1=1,3=1},lower=0,upper=0;第三轮循环,map的情况为{1=1,2=1,3=1},lower=1,upper=1,由于lower!=0,max=lower+当前值=2,upper=upper+当前值=2;第四轮循环,map的情况为{1=1,2=2,3=1},lower=lower+当前值=3,upper=3…从这里大致就能理解整个逻辑了,也就是从循环中取值,判断当前值的前后是否有值,如果有则将其前项或后项的值和当前值相加,判断它们与max之间的关系,如果比max大则更新max.</p>
<hr>
<p>Problem 606 Construct String from Binary Tree<br><img src="https://s2.ax1x.com/2019/09/24/uFb8XQ.png" alt="uFb8XQ.png"><br>将二叉树的结构输出成String,当左子树为空的时候保留输出(),当右子树为空时不输出(),其余时候均为(node.val)</p>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String tree2str(TreeNode t) &#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String output = String.valueOf(t.val);</span><br><span class="line">        if (t.left != null || t.right != null) &#123;</span><br><span class="line">            output += &quot;(&quot; + tree2str(t.left) + &quot;)&quot;;</span><br><span class="line">            if (t.right != null) &#123;</span><br><span class="line">                output += &quot;(&quot; + tree2str(t.right) + &quot;)&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>代码说明:<br>该题只需要简单的判断即可遍历完成,唯一需要注意的点就是左子树为空时需要补全(),也就是需要加一层判断</p>
<hr>
<p>Problem 617 Merge Two Binary Trees<br><img src="https://s2.ax1x.com/2019/09/24/uFbTnH.png" alt="uFbTnH.png"><br>如题目名所说,合并两棵树,若对应结点均有值则相加,没有则由另一个课的值补全.</p>
<hr>
<p>主要思路:<br>还是传统方法,先判断各自节点的安全性,之后就是对对应点相加并且同时遍历两棵树的左子树和右子树,不过这里需要注意的是由于两棵树合并之后的树相当于是新树,所以可以重新创建结点.</p>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;</span><br><span class="line">        if (t1==null&amp;&amp;t2==null)</span><br><span class="line">            return null;</span><br><span class="line">        if (t1==null)</span><br><span class="line">            return t2;</span><br><span class="line">        if (t2==null)</span><br><span class="line">            return t1;</span><br><span class="line">        TreeNode res = new TreeNode(t1.val+t2.val);</span><br><span class="line">        res.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        res.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Problem 643 Maximum Average Subarray I<br><img src="https://s2.ax1x.com/2019/09/24/uFLWQO.png" alt="uFLWQO.png"><br>找出给定个数的和最大的子序列</p>
<hr>
<p>主要思路:<br>这个题目其实用双循环可以简单解决,但是双循环很容易触发时间限制.所以可以采用滑动窗口策略,所谓滑动窗口就是先将指定数量(比如K)的数组元素相加,之后以K为起始点,减去i-K<br>位置的元素,加上当前位置的元素即可完成一次滑动.比如题目中给出的K=4,先算出0 1 2 3元素的和,再从4开始计算,先用和减去0位置的元素,再加上4位置的元素,并且比较和与最大值的大小,之后依次循环.</p>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double findMaxAverage(int[] nums, int k) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0;i&lt;k;i++)</span><br><span class="line">            sum+= nums[i];</span><br><span class="line">        int res = sum;</span><br><span class="line">        for(int i = k;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i]-nums[i-k];</span><br><span class="line">            res = Math.max(res,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return (double) res/k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Problem 653 Two Sum IV - Input is a BST<br><img src="https://s2.ax1x.com/2019/09/24/uFjWlV.png" alt="uFjWlV.png"><br>找出二叉搜索树中是否存在两个数相加等于给定值.</p>
<hr>
<p>主要思路:<br>既然是二叉搜索树,那么使用中序遍历自然能获得一个排序好的序列,之后只要存入map,判断给定值-当前值在map中是否存在即可.但是这样的效率似乎不够高.</p>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; tree = new ArrayList&lt;&gt;();</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    public boolean findTarget(TreeNode root, int k) &#123;</span><br><span class="line">        treeIn(root);</span><br><span class="line">        Map&lt;Integer,Boolean&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        if (tree.size()&lt;2)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (k&lt;(tree.get(0)+tree.get(1))||k&gt;(tree.get(tree.size()-1)+tree.get(tree.size()-2)))</span><br><span class="line">                return false;</span><br><span class="line">            for (int i=0;i&lt;tree.size();i++)&#123;</span><br><span class="line">                map.put(tree.get(i),true);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i=0;i&lt;tree.size();i++)&#123;</span><br><span class="line">                map.put(tree.get(i),false);</span><br><span class="line">                flag = map.get(k-tree.get(i))==null?false:map.get(k-tree.get(i));</span><br><span class="line">                if (flag)</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; treeIn(TreeNode root)&#123;</span><br><span class="line">        if (root==null)</span><br><span class="line">            return tree;</span><br><span class="line">        else &#123;</span><br><span class="line">            treeIn(root.left);</span><br><span class="line">            tree.add(root.val);</span><br><span class="line">            treeIn(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        return tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Problem 665 Non-decreasing Array<br><img src="https://s2.ax1x.com/2019/09/24/uFxYxP.png" alt="uFxYxP.png"><br>在至多可以替换一个数字的条件下,判断当前整数数组是否满足单调不减.</p>
<hr>
<p>主要思路:<br>该题主要是判断两种情况:</p>
<ul>
<li>出现两次当前数比其后一位数字要大</li>
<li>只出现一次当前数比其后一位数字大,但是其后两位数字却比其前一位数字要小,比如5,6,7,10,3,4,5.这里只有10&gt;3属于当前数大于后一位数的情况,但是10之后的3,4,5都不大于10之前的数,所以就算更改10,也无法改变当前数组不属于单调不减数组的情况.</li>
</ul>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean checkPossibility(int[] nums) &#123;</span><br><span class="line">        for(int i = 0; i &lt; nums.length - 1; i++)&#123;</span><br><span class="line">            if(nums[i] &gt; nums[i+1])&#123;</span><br><span class="line">                for(int j = i + 1; j &lt; nums.length - 1; j++)&#123;</span><br><span class="line">                    if (nums[j] &gt; nums[j+1])</span><br><span class="line">                        return false;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i == 0 || i + 2 &gt; nums.length - 1)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                if(nums[i] &gt; nums[i + 2])&#123;</span><br><span class="line">                    return nums[i - 1] &lt;= nums[i + 1];</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Problem 669 Trim a Binary Search Tree<br><img src="https://s2.ax1x.com/2019/09/24/uk9WlR.png" alt="uk9WlR.png"><br>给点最小值和最大值,将二叉搜索树中不在此范围内的结点进行裁剪,重新组成一颗二叉搜索树.</p>
<hr>
<p>主要思路:<br>以根结点为出发点构建树,如果最小值比root大则进入右子树并将其作为新的root,如果最大值比root小,则进入左子树,并将其作为新的root,之后只需要常规的递归就能得到裁剪后的二叉搜索树.</p>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode trimBST(TreeNode root, int L, int R) &#123;</span><br><span class="line">        if (root==null)</span><br><span class="line">            return null;</span><br><span class="line">        if (L&gt;root.val)&#123;</span><br><span class="line">            root = trimBST(root.right,L,R);</span><br><span class="line">        &#125;else if (R&lt;root.val)&#123;</span><br><span class="line">            root = trimBST(root.left,L,R);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            root.left = trimBST(root.left,L,R);</span><br><span class="line">            root.right = trimBST(root.right,L,R);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Problem 680 Valid Palindrome II<br><img src="https://s2.ax1x.com/2019/09/24/ukkyRg.png" alt="ukkyRg.png"><br>在至多删除一个字符的情况下,判断字符串是否属于回文.</p>
<hr>
<p>主要思路:<br>这个题目开始思考的时候还在想如果遇到需要删除的情况如何处理,但其实这题的关键就是抓住回文序列对应相等即可,如果遇到不相等的情况则删除左边字符或者右边字符.最后综合判断两边的情况.</p>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean validPalindrome(String s) &#123;</span><br><span class="line">        return helper(s, 0, s.length() - 1, true);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean helper(String s, int l, int r, boolean okRemove) &#123;</span><br><span class="line">        if (l &gt;= r)</span><br><span class="line">            return true;</span><br><span class="line">        if (s.charAt(l) == s.charAt(r))</span><br><span class="line">            return helper(s, l + 1, r - 1, okRemove);</span><br><span class="line">        else</span><br><span class="line">            return okRemove &amp;&amp; (helper(s, l + 1, r, false) || helper(s, l, r - 1, false));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Problem 696 Count Binary Substrings<br><img src="https://s2.ax1x.com/2019/09/24/ukZfcF.png" alt="ukZfcF.png"><br>寻找字符串中0和1数量相同的子序列的个数</p>
<hr>
<p>主要思路:<br>本题也属于数数问题,这类计数比较问题都可以通过暴力循环解决,但是时间复杂度上无法通过.就这题来说处理的关键在于从0变到1和1变到0的过程.以001110011为例.它可以划分成0011、1100、0011这三大部分,而这些部分是这样选取的,先统计00为2个,然后遍历到111,此时虽然有3个1,但是根据题目要求0和1数量要相同,所以只能取2个1.然后这3个1切换到0时,0也有2个,此时依然只能取2个1,也就是说部分的选取是以0和1切换之后0和1的数量中较小的那个决定的.而在类似(00001111)内部自然可以组成(01)对组合(此处为4对),把握好这个关系就能求解出来.</p>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countBinarySubstrings(String s) &#123;</span><br><span class="line">        if(s == null || s.length() == 0) return 0;</span><br><span class="line">        </span><br><span class="line">        int rem = 0, count = 1;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 1; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if(s.charAt(i) == s.charAt(i - 1))</span><br><span class="line">                count ++;</span><br><span class="line">            else &#123;</span><br><span class="line">                rem = count;</span><br><span class="line">                count = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(count &lt;= rem)</span><br><span class="line">                result ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>代码说明:<br>这里的rem就是用来保留切换前的0或者1的数量,然后当新的1或0的数量赶上rem的值之前result++.</p>
<hr>
<p>Problem 687 Longest Univalue Path<br><img src="https://s2.ax1x.com/2019/09/24/ukns7d.png" alt="ukns7d.png"><br>寻找值相同的最长路径.</p>
<hr>
<p>主要思路:<br>采用后项遍历对二叉树进行遍历,原因是计算左右子树相同,其父结点与它们不同则无法形成通路.而在递归的过程中需要注意几个问题.其中最重要的就是值的返回问题,这里返回的是<br>Math.max(rootWithLeft, rootWithRight),它是指的单个结点的左右子树中相同值的最大深度,因为左右子树路径必然只能选择其一.当遍历完一个完成左右子树+父结点后就开始比较该路径与最大路径的大小.</p>
<hr>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int longestUnivaluePath(TreeNode root) &#123;</span><br><span class="line">        int[] res = &#123;0&#125;;</span><br><span class="line">        helper(root, res);</span><br><span class="line">        return res[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int helper(TreeNode node, int[] res) &#123;</span><br><span class="line">        if (node == null) return 0;</span><br><span class="line">        int left = helper(node.left, res);</span><br><span class="line">        int right = helper(node.right, res);</span><br><span class="line">        int rootWithLeft = 0, rootWithRight = 0;</span><br><span class="line">        if (node.left != null &amp;&amp; node.left.val == node.val) &#123;</span><br><span class="line">            rootWithLeft = 1 + left;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right != null &amp;&amp; node.right.val == node.val) &#123;</span><br><span class="line">            rootWithRight = 1 + right;</span><br><span class="line">        &#125;</span><br><span class="line">        res[0] = Math.max(res[0], rootWithLeft + rootWithRight);</span><br><span class="line">        return Math.max(rootWithLeft, rootWithRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/21/Leetcode刷题记录(Java) _09_21/" rel="next" title="Leetcode刷题记录(Java)">
                <i class="fa fa-chevron-left"></i> Leetcode刷题记录(Java)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/24/Leetcode刷题记录(Java) _09_24/" rel="prev" title="Leetcode刷题记录(Java)">
                Leetcode刷题记录(Java) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/batman.png"
                alt="Tony Wu" />
            
              <p class="site-author-name" itemprop="name">Tony Wu</p>
              <p class="site-description motion-element" itemprop="description">一些算法、一些划水</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-google"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tony Wu</span>

  
</div>










        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
